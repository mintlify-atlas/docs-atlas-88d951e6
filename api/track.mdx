---
title: "Track"
description: "Record usage events for metered and usage-based features"
api: "POST https://api.useautumn.com/v1/track"
---

## Overview

The `/track` endpoint records usage events for metered or usage-based features. Use it to:
- Decrement balance after feature usage
- Track consumption of credits, tokens, or API calls
- Record seat assignments or storage usage
- Build usage-based billing models
- Create audit trails of feature consumption

Every time a customer uses a metered feature, call this endpoint to record the usage. The balance is automatically deducted and usage data is stored for billing and analytics.

## Authentication

<ParamField header="Authorization" type="string" required>
  Bearer token with your Autumn API key. Use your public key for client-side requests and secret key for server-side requests.
</ParamField>

## Request Body

<ParamField body="customer_id" type="string" required>
  ID which you provided when creating the customer. This uniquely identifies the customer in your system.
</ParamField>

<ParamField body="feature_id" type="string">
  ID of the feature to track usage for. Required if `event_name` is not provided. Use this for direct feature tracking.
</ParamField>

<ParamField body="event_name" type="string">
  An event name can be used in place of `feature_id`. This allows tracking multiple features in the same event. For example, an "ai_generation" event might consume both "ai_tokens" and "generations" features. See the [tracking usage guide](/features/tracking-usage#using-event-names) for details.
</ParamField>

<ParamField body="value" type="number" default={1}>
  The amount of usage to record. Defaults to 1 if not provided. Can be negative to increase the balance (e.g., when removing a seat or refunding credits).
</ParamField>

<ParamField body="idempotency_key" type="string">
  Unique key to prevent duplicate event recording. Use this to safely retry requests without creating duplicate usage records. If the same idempotency key is sent twice, the second request will be ignored.
</ParamField>

<ParamField body="entity_id" type="string">
  If using entity balances (e.g., seats or teams), the entity ID to track usage for. This records usage against a specific entity within the customer's account.
</ParamField>

<ParamField body="customer_data" type="object">
  Additional customer properties. These will be used to create or update the customer if they don't exist or their properties are not already set.

  <Expandable title="customer_data properties">
    <ParamField body="customer_data.name" type="string">
      Customer's full name
    </ParamField>
    <ParamField body="customer_data.email" type="string">
      Customer's email address (must be valid email format)
    </ParamField>
    <ParamField body="customer_data.metadata" type="object">
      Additional custom metadata to store with the customer
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="properties" type="object">
  Additional properties to attach to this usage event. Use this to store metadata about the usage for analytics or debugging. For example: `{ "model": "gpt-4", "tokens": 1500, "endpoint": "/v1/chat" }`
</ParamField>

<ParamField body="overage_behavior" type="string">
  How to handle usage when balance is insufficient. Options:
  - `"cap"` - Limits usage to available balance (partial consumption)
  - `"reject"` - Prevents the usage entirely (throws error)
  
  If not specified, the feature's default overage behavior is used.
</ParamField>

## Query Parameters

<ParamField query="skip_cache" type="boolean" default={false}>
  Skip cached balance data and fetch fresh data from the database. Use this when you need real-time accuracy.
</ParamField>

<ParamField query="expand" type="string[]">
  Expand related objects in the response. Available values:
  - `balance.feature` - Include full feature details in the balance object
</ParamField>

## Response

<ResponseField name="customer_id" type="string" required>
  The ID of the customer
</ResponseField>

<ResponseField name="entity_id" type="string">
  The ID of the entity (if provided in request)
</ResponseField>

<ResponseField name="event_name" type="string">
  The name of the event (if provided in request)
</ResponseField>

<ResponseField name="value" type="number" required>
  The amount of usage that was recorded
</ResponseField>

<ResponseField name="balance" type="object | null" required>
  Updated balance information after recording usage. Will be `null` if tracking an event that doesn't affect balance.

  <Expandable title="balance properties">
    <ResponseField name="balance.feature_id" type="string" required>
      The feature ID this balance is for
    </ResponseField>

    <ResponseField name="balance.unlimited" type="boolean" required>
      Whether this feature has unlimited access
    </ResponseField>

    <ResponseField name="balance.granted_balance" type="number" required>
      The base balance granted by the customer's plan
    </ResponseField>

    <ResponseField name="balance.purchased_balance" type="number" required>
      Additional balance purchased beyond the base plan
    </ResponseField>

    <ResponseField name="balance.current_balance" type="number" required>
      The remaining balance available after this usage
    </ResponseField>

    <ResponseField name="balance.usage" type="number" required>
      Total usage consumed in the current billing period (including this event)
    </ResponseField>

    <ResponseField name="balance.overage_allowed" type="boolean" required>
      Whether usage beyond the balance is allowed
    </ResponseField>

    <ResponseField name="balance.max_purchase" type="number | null" required>
      Maximum additional balance that can be purchased (null if unlimited)
    </ResponseField>

    <ResponseField name="balance.reset" type="object | null" required>
      Information about when the balance resets

      <Expandable title="reset properties">
        <ResponseField name="balance.reset.interval" type="string" required>
          Reset interval (e.g., "month", "year", "week", "day")
        </ResponseField>

        <ResponseField name="balance.reset.resets_at" type="number | null" required>
          Unix timestamp (milliseconds) of next reset
        </ResponseField>
      </Expandable>
    </ResponseField>

    <ResponseField name="balance.plan_id" type="string | null" required>
      The plan ID that granted this balance
    </ResponseField>

    <ResponseField name="balance.feature" type="object">
      Full feature details (only included if `expand=balance.feature` query parameter is used)
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="balances" type="object">
  When tracking by `event_name`, this contains a map of feature_id to balance for all features affected by the event. For example: `{ "ai_tokens": {...}, "generations": {...} }`
</ResponseField>

## Examples

### Track basic usage

<CodeGroup>

```bash curl
curl -X POST https://api.useautumn.com/v1/track \
  -H "Authorization: Bearer am_sk_..." \
  -H "Content-Type: application/json" \
  -d '{
    "customer_id": "user_123",
    "feature_id": "ai_tokens",
    "value": 1500
  }'
```

```javascript JavaScript
const response = await fetch('https://api.useautumn.com/v1/track', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer am_sk_...',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    customer_id: 'user_123',
    feature_id: 'ai_tokens',
    value: 1500,
  }),
});

const data = await response.json();
console.log(data);
// {
//   "customer_id": "user_123",
//   "value": 1500,
//   "balance": {
//     "feature_id": "ai_tokens",
//     "unlimited": false,
//     "granted_balance": 10000,
//     "purchased_balance": 0,
//     "current_balance": 6000,
//     "usage": 4000,
//     "overage_allowed": false,
//     "max_purchase": 50000,
//     "reset": {
//       "interval": "month",
//       "resets_at": 1709251200000
//     },
//     "plan_id": "pro_plan"
//   }
// }
```

```python Python
import requests

response = requests.post(
    'https://api.useautumn.com/v1/track',
    headers={
        'Authorization': 'Bearer am_sk_...',
        'Content-Type': 'application/json',
    },
    json={
        'customer_id': 'user_123',
        'feature_id': 'ai_tokens',
        'value': 1500,
    }
)

data = response.json()
print(f"Remaining balance: {data['balance']['current_balance']}")
```

</CodeGroup>

### Track with idempotency

Use idempotency keys to prevent duplicate tracking on retries:

<CodeGroup>

```bash curl
curl -X POST https://api.useautumn.com/v1/track \
  -H "Authorization: Bearer am_sk_..." \
  -H "Content-Type: application/json" \
  -d '{
    "customer_id": "user_123",
    "feature_id": "api_calls",
    "value": 1,
    "idempotency_key": "req_abc123xyz"
  }'
```

```javascript JavaScript
// Generate a unique key for each logical operation
const idempotencyKey = `${customerId}-${Date.now()}-${Math.random()}`;

const response = await fetch('https://api.useautumn.com/v1/track', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer am_sk_...',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    customer_id: 'user_123',
    feature_id: 'api_calls',
    value: 1,
    idempotency_key: idempotencyKey,
  }),
});

const data = await response.json();

// If this request is retried with the same idempotency_key,
// it won't create a duplicate event
```

```python Python
import requests
import uuid

# Generate unique idempotency key
idempotency_key = str(uuid.uuid4())

response = requests.post(
    'https://api.useautumn.com/v1/track',
    headers={
        'Authorization': 'Bearer am_sk_...',
        'Content-Type': 'application/json',
    },
    json={
        'customer_id': 'user_123',
        'feature_id': 'api_calls',
        'value': 1,
        'idempotency_key': idempotency_key,
    }
)

data = response.json()
```

</CodeGroup>

### Track with metadata

Add custom properties to track additional context:

<CodeGroup>

```bash curl
curl -X POST https://api.useautumn.com/v1/track \
  -H "Authorization: Bearer am_sk_..." \
  -H "Content-Type: application/json" \
  -d '{
    "customer_id": "user_123",
    "feature_id": "ai_tokens",
    "value": 2000,
    "properties": {
      "model": "gpt-4",
      "endpoint": "/v1/chat/completions",
      "prompt_tokens": 500,
      "completion_tokens": 1500
    }
  }'
```

```javascript JavaScript
const response = await fetch('https://api.useautumn.com/v1/track', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer am_sk_...',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    customer_id: 'user_123',
    feature_id: 'ai_tokens',
    value: 2000,
    properties: {
      model: 'gpt-4',
      endpoint: '/v1/chat/completions',
      prompt_tokens: 500,
      completion_tokens: 1500,
    },
  }),
});

const data = await response.json();
// Properties are stored with the event for analytics
```

```python Python
import requests

response = requests.post(
    'https://api.useautumn.com/v1/track',
    headers={
        'Authorization': 'Bearer am_sk_...',
        'Content-Type': 'application/json',
    },
    json={
        'customer_id': 'user_123',
        'feature_id': 'ai_tokens',
        'value': 2000,
        'properties': {
            'model': 'gpt-4',
            'endpoint': '/v1/chat/completions',
            'prompt_tokens': 500,
            'completion_tokens': 1500,
        },
    }
)

data = response.json()
```

</CodeGroup>

### Track entity usage (seats)

Track usage for specific entities like teams:

<CodeGroup>

```bash curl
curl -X POST https://api.useautumn.com/v1/track \
  -H "Authorization: Bearer am_sk_..." \
  -H "Content-Type: application/json" \
  -d '{
    "customer_id": "org_456",
    "feature_id": "seats",
    "entity_id": "team_789",
    "value": 1
  }'
```

```javascript JavaScript
// Adding a new team member
const response = await fetch('https://api.useautumn.com/v1/track', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer am_sk_...',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    customer_id: 'org_456',
    feature_id: 'seats',
    entity_id: 'team_789',
    value: 1, // Adding 1 seat
  }),
});

const data = await response.json();
console.log(`Team now has ${data.balance.usage} active seats`);
```

```python Python
import requests

# Adding a new team member
response = requests.post(
    'https://api.useautumn.com/v1/track',
    headers={
        'Authorization': 'Bearer am_sk_...',
        'Content-Type': 'application/json',
    },
    json={
        'customer_id': 'org_456',
        'feature_id': 'seats',
        'entity_id': 'team_789',
        'value': 1,  # Adding 1 seat
    }
)

data = response.json()
print(f"Team now has {data['balance']['usage']} active seats")
```

</CodeGroup>

### Remove usage (negative value)

Use negative values to increase balance (e.g., removing seats or refunding credits):

<CodeGroup>

```bash curl
curl -X POST https://api.useautumn.com/v1/track \
  -H "Authorization: Bearer am_sk_..." \
  -H "Content-Type: application/json" \
  -d '{
    "customer_id": "org_456",
    "feature_id": "seats",
    "entity_id": "team_789",
    "value": -1
  }'
```

```javascript JavaScript
// Removing a team member
const response = await fetch('https://api.useautumn.com/v1/track', {
  method: 'POST',
  headers: {
    'Authorization': 'Bearer am_sk_...',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    customer_id: 'org_456',
    feature_id: 'seats',
    entity_id: 'team_789',
    value: -1, // Negative value increases balance
  }),
});

const data = await response.json();
console.log(`Seat removed. ${data.balance.current_balance} seats remaining`);
```

```python Python
import requests

# Removing a team member
response = requests.post(
    'https://api.useautumn.com/v1/track',
    headers={
        'Authorization': 'Bearer am_sk_...',
        'Content-Type': 'application/json',
    },
    json={
        'customer_id': 'org_456',
        'feature_id': 'seats',
        'entity_id': 'team_789',
        'value': -1,  # Negative value increases balance
    }
)

data = response.json()
```

</CodeGroup>

## Use Cases

### API call metering

Track every API call made by a customer:

```javascript
app.post('/api/endpoint', async (req, res) => {
  // Verify customer has access
  const checkResult = await autumn.check({
    customer_id: req.user.id,
    feature_id: 'api_calls',
    required_balance: 1,
  });

  if (!checkResult.allowed) {
    return res.status(403).json({ error: 'API call limit exceeded' });
  }

  // Process the request
  const result = await processRequest(req.body);

  // Track the usage
  await autumn.track({
    customer_id: req.user.id,
    feature_id: 'api_calls',
    value: 1,
    idempotency_key: `${req.user.id}-${req.id}`,
  });

  res.json(result);
});
```

### AI token consumption

Track token usage for AI features:

```javascript
async function generateAIResponse(prompt, customerId) {
  const response = await openai.createChatCompletion({
    model: 'gpt-4',
    messages: [{ role: 'user', content: prompt }],
  });

  const tokensUsed = response.usage.total_tokens;

  // Track the actual tokens consumed
  await autumn.track({
    customer_id: customerId,
    feature_id: 'ai_tokens',
    value: tokensUsed,
    properties: {
      model: 'gpt-4',
      prompt_tokens: response.usage.prompt_tokens,
      completion_tokens: response.usage.completion_tokens,
    },
  });

  return response.choices[0].message.content;
}
```

### Seat management

Track seat additions and removals:

```javascript
// Adding a team member
async function addTeamMember(teamId, userId) {
  await autumn.track({
    customer_id: getOrgId(teamId),
    feature_id: 'seats',
    entity_id: teamId,
    value: 1,
    properties: {
      user_id: userId,
      action: 'add_member',
    },
  });
}

// Removing a team member
async function removeTeamMember(teamId, userId) {
  await autumn.track({
    customer_id: getOrgId(teamId),
    feature_id: 'seats',
    entity_id: teamId,
    value: -1, // Negative to increase balance
    properties: {
      user_id: userId,
      action: 'remove_member',
    },
  });
}
```

### Storage tracking

Track storage usage with metadata:

```javascript
async function uploadFile(file, customerId) {
  const fileSizeGB = file.size / (1024 ** 3);

  // Check if customer has enough storage
  const checkResult = await autumn.check({
    customer_id: customerId,
    feature_id: 'storage_gb',
    required_balance: fileSizeGB,
  });

  if (!checkResult.allowed) {
    throw new Error('Insufficient storage');
  }

  // Upload the file
  const uploadResult = await s3.upload(file);

  // Track the storage usage
  await autumn.track({
    customer_id: customerId,
    feature_id: 'storage_gb',
    value: fileSizeGB,
    properties: {
      file_name: file.name,
      file_type: file.type,
      file_size_bytes: file.size,
      s3_key: uploadResult.key,
    },
  });

  return uploadResult;
}
```

## Error Handling

<ResponseField name="error" type="object">
  Error object returned when the request fails

  <Expandable title="error properties">
    <ResponseField name="error.code" type="string">
      Error code (e.g., "insufficient_balance", "feature_not_found", "customer_not_found")
    </ResponseField>
    <ResponseField name="error.message" type="string">
      Human-readable error message
    </ResponseField>
  </Expandable>
</ResponseField>

Common error codes:
- `insufficient_balance`: Customer doesn't have enough balance and overage is not allowed
- `feature_not_found`: Feature ID doesn't exist
- `customer_not_found`: Customer doesn't exist
- `validation_error`: Invalid request parameters
- `duplicate_event`: Event with this idempotency key already exists

## Related Endpoints

- [Check](/api/check) - Verify access before tracking usage
- [Events List](/api/events/list) - View usage history
- [Events Aggregate](/api/events/aggregate) - Analyze usage patterns
